//
//  FileActionMenuExtension.swift
//  Pocket Clouds
//
//  Created by Tyler on 28/05/2017.
//  Copyright Â© 2017 TylerSwann. All rights reserved.
//

import Foundation
import UIKit
import SSZipArchive

extension FileViewController
{
    @objc internal func actionClick()
    {
        let actionsheet = UIAlertController(title: nil, message: nil, preferredStyle: .actionSheet)
        let selectAllButton = UIAlertAction(title: "Select All", style: .default, handler: {_ in self.selectAll()})
        let cancelButton = UIAlertAction(title: "Cancel", style: .cancel, handler: nil)
        let exportToPCButton = UIAlertAction(title: "Export To Computer", style: .default, handler: {_ in self.exportToPC()})
        let exportToLibrary = UIAlertAction(title: "Export Images To library", style: .default, handler: {_ in self.exportToLibrary()})
        let loadingDemoButton = UIAlertAction(title: "Loading Demo", style: .default, handler: {_ in self.showLoadingDemo()})
        let zipButton = UIAlertAction(title: "Zip files", style: .default, handler: {_ in self.zipSelectedFiles()})
        let duplicateButton = UIAlertAction(title: "Duplicate", style: .default, handler: {_ in self.duplicateClick()})
        let buttons = [loadingDemoButton, exportToPCButton, exportToLibrary, zipButton, duplicateButton,selectAllButton, cancelButton]
        buttons.forEach({button in actionsheet.addAction(button)})
        self.present(actionsheet, animated: true, completion: nil)
    }
    
    func duplicateClick()
    {
        let selectedPaths = self.getPathsForSelectedIndexPaths()
        guard selectedPaths.count > 0 else {return}
        selectedPaths.forEach({path in
            let filename = path.toURL().lastPathComponent
            let fileExtension = path.toURL().pathExtension
            var newFilename = filename.replacingOccurrences(of: ".\(fileExtension)", with: "-Copy")
            var newFilePath = "\(path.replacingOccurrences(of: "/\(filename)", with: ""))/\(newFilename).\(fileExtension)"
            if (fileExists(atPath: newFilePath))
            {
                newFilename = filename.replacingOccurrences(of: ".\(fileExtension)", with: "-Copy\(randomNumber())")
                newFilePath = "\(path.replacingOccurrences(of: "/\(filename)", with: ""))/\(newFilename).\(fileExtension)"
            }
            do
            {
                try FileManager.default.copyItem(atPath: path, toPath: newFilePath)
            }
            catch let error {print(error)}
        })
        self.reloadCollectionView(reload: nil, completion: nil)
    }
    
    func zipSelectedFiles()
    {
        let filemanager = FileManager.default
        let tempFoldername = File.autoGeneratedSimpleFileName(forMediatype: .archive)
        let tempFolderPath = "\(Directory.currentpath)/\(tempFoldername)"
        let selectedFiles = self.getPathsForSelectedIndexPaths()
        let message = "You can leave the password field blank if you don't want it password protected"
        let alertController = UIAlertController(title: "Create Zip Archive", message: message, preferredStyle: .alert)
        let cancelButton = UIAlertAction(title: "Cancel", style: .cancel, handler: nil)
        let zipButton = UIAlertAction(title: "Zip", style: .default, handler: {_ in
            var password: String? = nil
            if let textfield = alertController.textFields?.first{password = textfield.text}
            self.createFolderAt(path: tempFolderPath)
            let usingPassword = password == "" ? false : true
            if (self.fileExists(atPath: tempFolderPath))
            {
                do
                {
                    try selectedFiles.forEach({currentpath in
                        let filename = currentpath.toURL().lastPathComponent
                        let tempFilepath = "\(tempFolderPath)/\(filename)"
                        try filemanager.copyItem(atPath: currentpath, toPath: tempFilepath)
                    })
                }
                catch let error{print(error)}
                var success = false
                if (usingPassword)
                {
                    success = SSZipArchive.createZipFile(atPath: "\(tempFolderPath).zip", withContentsOfDirectory: tempFolderPath, withPassword: password)
                }
                else
                {
                    success = SSZipArchive.createZipFile(atPath: "\(tempFolderPath).zip", withContentsOfDirectory: tempFolderPath)
                }
                do
                {
                    try filemanager.removeItem(atPath: tempFolderPath)
                }
                catch let error {print(error)}
                if (!success){self.createMessageBox(withMessage: "Sorry, couldn't create zip archive", title: "Error", andShowOnViewController: self)}
                else {self.reloadCollectionView(reload: nil, completion: nil)}
            }
            else {print("Couldnt find temp folder")}
        })
        alertController.addTextField(configurationHandler: {textfield in
            textfield.placeholder = "Password?..."
            textfield.isSecureTextEntry = true
            textfield.keyboardAppearance = .dark
        })
        alertController.addAction(cancelButton)
        alertController.addAction(zipButton)
        self.present(alertController, animated: true, completion: nil)
    }
    
    func exportToPC()
    {
        let progressRing = UIProgressRing(message: "Exporting...", presentOn: self)
        let pathsToExport = self.getPathsForSelectedIndexPaths()
        var totalProgress = CGFloat(0)
        let totalCount = CGFloat(pathsToExport.count)
        let onePercent = CGFloat(100) / totalCount
        progressRing.show()
        DispatchQueue.global(qos: .userInitiated).async
        {
            let filemanager = FileManager.default
            do
            {
                try self.getPathsForSelectedIndexPaths().forEach({oldPath in
                    let filename = oldPath.toURL().lastPathComponent
                    let newPath = "\(Directory.systemDocuments)/\(filename)"
                    try filemanager.copyItem(atPath: oldPath, toPath: newPath)
                    totalProgress += onePercent
                    DispatchQueue.main.async{progressRing.setProgess(value: totalProgress, animationDuration: 1.0)}
                })
            }
            catch let error {print(error)}
        }
        DispatchQueue.main.async
        {
            self.changeCurrentState(to: .normal)
            progressRing.dismiss()
        }
    }
    func exportToLibrary()
    {
        let progressRing = UIProgressRing(message: "Saving...", presentOn: self)
        var imagesToExport = [UIImage]()
        self.getPathsForSelectedIndexPaths().forEach({path in
            if (path.mediatype() == .image)
            {
                if let image = UIImage(contentsOfFile: path)
                {
                    imagesToExport.append(image)
                }
            }
        })
        if (imagesToExport.count <= 0){return}
        progressRing.show()
        var totalProgress = CGFloat(0)
        let totalExportCount = CGFloat(imagesToExport.count)
        let onePercent = CGFloat(100) / totalExportCount
        DispatchQueue.global(qos: .userInitiated).async
        {
            imagesToExport.forEach({image in
                UIImageWriteToSavedPhotosAlbum(image, nil, nil, nil)
                totalProgress += onePercent
                DispatchQueue.main.async{progressRing.setProgess(value: totalProgress, animationDuration: 1.0)}
            })
        }
        DispatchQueue.main.async{progressRing.dismiss(); self.changeCurrentState(to: .normal)}
    }
    
    func getPathsForSelectedIndexPaths() -> [String]
    {
        var selectedFilePaths = [String]()
        let selectedIndexPaths = self.getSelectedIndexPaths()
        selectedIndexPaths.forEach({indexPath in
            let path = "\(Directory.currentpath)/\(self.files[indexPath.item])"
            selectedFilePaths.append(path)
        })
        return selectedFilePaths
    }
    
    func getSelectedIndexPaths() -> [IndexPath]
    {
        var indexPathsForSelectedItems = [IndexPath]()
        if let selectedIndexs = self.collectionView.indexPathsForSelectedItems
        {
            indexPathsForSelectedItems = selectedIndexs
        }
        return indexPathsForSelectedItems
    }
    
    func showLoadingDemo()
    {
        let loadingRing = UIInfiniteProgressRing(message: "Loading...", presentOn: self)
        loadingRing.showAndAnimate()
        DispatchQueue.main.asyncAfter(deadline: .now() + .seconds(7), execute: {loadingRing.dismissAndStopAnimation()})
//        let loadingRing = UIProgressRing(message: "Loading...", presentOn: self)
//        loadingRing.show()
//        var totalProgress = CGFloat(0)
//        for _ in 0...99
//        {
//            DispatchQueue.main.asyncAfter(deadline: .now() + .seconds(2), execute: {
//                totalProgress += CGFloat(1)
//                loadingRing.setProgess(value: totalProgress, animationDuration: 0)
//            })
//        }
//        DispatchQueue.main.asyncAfter(deadline: .now() + .seconds(5), execute: {loadingRing.dismiss()})
    }
}






